{
  "active": true,
  "connections": {
    "Edit Fields": {
      "main": [
        [
          {
            "node": "Split Out",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "LoopOverItems": {
      "main": [
        [],
        [
          {
            "node": "Call 'My workflow 2'",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Split Out": {
      "main": [
        [
          {
            "node": "LoopOverItems",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Call 'My workflow 2'": {
      "main": [
        [
          {
            "node": "UpdateAggregate",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Trigger 1/Week/Sun": {
      "main": [
        [
          {
            "node": "Edit Fields",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "UpdateAggregate": {
      "main": [
        [
          {
            "node": "LoopOverItems",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "createdAt": "2025-11-06T03:12:24.502Z",
  "id": "wH0dkSQYG5ytMNCj",
  "isArchived": false,
  "meta": null,
  "name": "UpdateServers",
  "nodes": [
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "48863004-a323-48e9-b0b7-bcaf58ab8ea8",
              "name": "ips",
              "value": "[\"10.0.0.201\", \"10.0.0.202\", \"10.0.0.203\", \"10.0.0.204\", \"10.0.0.205\", \"10.0.0.206\", \"10.0.0.207\" ]",
              "type": "array"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        192,
        0
      ],
      "id": "17604237-3a1e-4684-9bf5-6d2ebb2af0c4",
      "name": "Edit Fields"
    },
    {
      "parameters": {
        "options": {
          "reset": false
        }
      },
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [
        928,
        32
      ],
      "id": "14ebc04e-afa2-44da-a177-bb0ce326cd4b",
      "name": "LoopOverItems",
      "executeOnce": false
    },
    {
      "parameters": {
        "fieldToSplitOut": "ips",
        "options": {}
      },
      "type": "n8n-nodes-base.splitOut",
      "typeVersion": 1,
      "position": [
        416,
        0
      ],
      "id": "8cc0bf4c-b878-4819-8ec4-5a45388163fd",
      "name": "Split Out"
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "VCdlQdIQp6H4QPNg",
          "mode": "list",
          "cachedResultUrl": "/workflow/VCdlQdIQp6H4QPNg",
          "cachedResultName": "update machines"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "ip_address": "={{ $json.ips }}"
          },
          "matchingColumns": [
            "ip_address"
          ],
          "schema": [
            {
              "id": "ip_address",
              "displayName": "ip_address",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": true
        },
        "options": {}
      },
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.3,
      "position": [
        1216,
        48
      ],
      "id": "c02e18c9-a803-4fcc-9b6f-eadfec9e4379",
      "name": "Call 'My workflow 2'",
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "weeks"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.2,
      "position": [
        0,
        0
      ],
      "id": "290b5345-0bd7-49b7-9fd2-1f548115d58b",
      "name": "Trigger 1/Week/Sun"
    },
    {
      "parameters": {
        "jsCode": "// Helper function to get status emoji and color\n  function getStatusIndicators(success) {\n    if (success) {\n      return {\n        emoji: '‚úÖ',\n        color: 3066993, // Green\n        status: 'SUCCESS'\n      };\n    } else {\n      return {\n        emoji: '‚ùå',\n        color: 15158332, // Red\n        status: 'FAILED'\n      };\n    }\n  }\n\n  // Helper function to format duration\n  function formatDuration(seconds) {\n    if (!seconds || isNaN(seconds)) return 'N/A';\n    if (seconds < 60) return `${seconds}s`;\n    const minutes = Math.floor(seconds / 60);\n    const remainingSeconds = seconds % 60;\n    return `${minutes}m ${remainingSeconds}s`;\n  }\n\n  // Helper function to safely get value\n  function safeValue(val, defaultVal = 'N/A') {\n    return (val !== undefined && val !== null && val !== '') ? val : defaultVal;\n  }\n\n  // Get deployment data from the workflow\n  // Adjust these based on your actual n8n workflow data structure\n  const deploymentData = $input.first().json;\n\n  const result = {\n    timestamp: new Date().toISOString(),\n    deployment: {},\n    discord_embed: {}\n  };\n\n  // Extract deployment information\n  // Modify these field names based on your actual ArgoCD/deployment webhook/API response\n  result.deployment = {\n    app_name: safeValue(deploymentData.app_name || deploymentData.application),\n    namespace: safeValue(deploymentData.namespace || 'n8n'),\n    success: deploymentData.success === true || deploymentData.status === 'Healthy' || deploymentData.sync_status === 'Synced',\n    revision: safeValue(deploymentData.revision || deploymentData.git_commit),\n    sync_status: safeValue(deploymentData.sync_status),\n    health_status: safeValue(deploymentData.health_status),\n    duration: safeValue(deploymentData.duration),\n    message: safeValue(deploymentData.message || deploymentData.error),\n    resources_updated: deploymentData.resources_updated || [],\n    initiated_by: safeValue(deploymentData.initiated_by || deploymentData.user),\n    environment: safeValue(deploymentData.environment || 'production')\n  };\n\n  // Get status indicators\n  const indicators = getStatusIndicators(result.deployment.success);\n\n  // Create Discord-formatted summary\n  const tick3 = '```';\n  let summary = '';\n\n  // Status header\n  summary += `${indicators.emoji} **Deployment ${indicators.status}**\\n\\n`;\n\n  // Application info\n  summary += `**üì¶ Application Details**\\n`;\n  summary += tick3 + '\\n';\n  summary += `Name:        ${result.deployment.app_name}\\n`;\n  summary += `Namespace:   ${result.deployment.namespace}\\n`;\n  summary += `Environment: ${result.deployment.environment}\\n`;\n  summary += tick3 + '\\n';\n\n  // Sync information\n  summary += `**üîÑ Sync Information**\\n`;\n  summary += tick3 + '\\n';\n  summary += `Status:      ${result.deployment.sync_status}\\n`;\n  summary += `Health:      ${result.deployment.health_status}\\n`;\n  summary += `Revision:    ${result.deployment.revision}\\n`;\n  if (result.deployment.duration) {\n    summary += `Duration:    ${formatDuration(result.deployment.duration)}\\n`;\n  }\n  summary += tick3 + '\\n';\n\n  // Resources updated (if available)\n  if (result.deployment.resources_updated && result.deployment.resources_updated.length > 0) {\n    summary += `**üìù Resources Updated**\\n`;\n    summary += tick3 + '\\n';\n    result.deployment.resources_updated.forEach(resource => {\n      summary += `‚Ä¢ ${resource}\\n`;\n    });\n    summary += tick3 + '\\n';\n  }\n\n  // Message or error details\n  if (result.deployment.message && result.deployment.message !== 'N/A') {\n    const messageTitle = result.deployment.success ? '**üìã Message**' : '**‚ö†Ô∏è Error Details**';\n    summary += `${messageTitle}\\n`;\n    summary += tick3 + '\\n';\n    summary += `${result.deployment.message}\\n`;\n    summary += tick3 + '\\n';\n  }\n\n  // Initiated by\n  if (result.deployment.initiated_by && result.deployment.initiated_by !== 'N/A') {\n    summary += `*Initiated by: ${result.deployment.initiated_by}*\\n`;\n  }\n\n  result.summary = summary;\n\n  // Create Discord embed\n  result.discord_embed = {\n    embeds: [{\n      title: `${indicators.emoji} ${result.deployment.app_name} - ${indicators.status}`,\n      description: summary,\n      color: indicators.color,\n      timestamp: new Date().toISOString(),\n      footer: {\n        text: `ArgoCD Deployment Monitor ‚Ä¢ ${result.deployment.environment}`\n      },\n      fields: [\n        {\n          name: 'üì¶ Application',\n          value: result.deployment.app_name,\n          inline: true\n        },\n        {\n          name: 'üè∑Ô∏è Namespace',\n          value: result.deployment.namespace,\n          inline: true\n        },\n        {\n          name: 'üîÑ Status',\n          value: `${result.deployment.sync_status} / ${result.deployment.health_status}`,\n          inline: true\n        }\n      ]\n    }]\n  };\n\nreturn [{ json: result }];"
      },
      "id": "cdf6d53f-0c0f-4694-8dec-1faf3e1c9c38",
      "name": "ArgocdNotification1",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1344,
        -176
      ]
    },
    {
      "parameters": {
        "jsCode": "// Helper function to get status emoji and color\nfunction getStatusIndicators(hasUpdates, hasCritical = false) {\n  if (hasCritical) {\n    return {\n      emoji: 'üî¥',\n      color: 15158332, // Red\n      status: 'CRITICAL UPDATES'\n    };\n  } else if (hasUpdates) {\n    return {\n      emoji: 'üü°',\n      color: 16776960, // Yellow\n      status: 'UPDATES AVAILABLE'\n    };\n  } else {\n    return {\n      emoji: '‚úÖ',\n      color: 3066993, // Green\n      status: 'UP TO DATE'\n    };\n  }\n}\n\n// Helper function to format date\nfunction formatDate(dateStr) {\n  if (!dateStr) return 'N/A';\n  try {\n    return new Date(dateStr).toLocaleString();\n  } catch {\n    return dateStr;\n  }\n}\n\n// Helper function to safely get value\nfunction safeValue(val, defaultVal = 'N/A') {\n  return (val !== undefined && val !== null && val !== '') ? val : defaultVal;\n}\n\n// Get the current IP\nconst currentIp = $('LoopOverItems').first().json.ips\n\n// Collect all update information for this IP\nconst result = {\n  ip: currentIp,\n  timestamp: new Date().toISOString(),\n  updates: {\n    packages: [],\n    services: [],\n    security: [],\n    kernel: null,\n    system_info: {}\n  },\n  stats: {\n    total_updates: 0,\n    security_updates: 0,\n    service_restarts: 0,\n    last_update: null\n  },\n  summary: '',\n  discord_embed: {}\n};\n\n// Process each command result\nfor (const item of $input.all()) {\n  console.log('Processing item:', JSON.stringify(item.json, null, 2));\n  \n  // Try to get command/update type from different possible properties\n  const updateType = item.json.update_type || item.json.command_name || item.json.type;\n  \n  console.log('Update type:', updateType);\n  \n  // Check if data is in stdout or directly in json\n  let parsedData;\n  if (item.json.stdout) {\n    try {\n      parsedData = JSON.parse(item.json.stdout);\n    } catch (error) {\n      parsedData = {\n        error: 'Failed to parse output',\n        raw_output: item.json.stdout\n      };\n    }\n  } else {\n    // Data might be directly in the json object\n    parsedData = item.json;\n  }\n  \n  // Detect update type from data structure if not specified\n  let detectedType = updateType;\n  if (!detectedType) {\n    if (parsedData.packages !== undefined) detectedType = 'packages';\n    else if (parsedData.services !== undefined) detectedType = 'services';\n    else if (parsedData.security_patches !== undefined) detectedType = 'security';\n    else if (parsedData.kernel_version !== undefined) detectedType = 'kernel';\n    else if (parsedData.os_version !== undefined) detectedType = 'system_info';\n  }\n  \n  console.log('Detected type:', detectedType);\n  \n  // Store the data based on type\n  switch(detectedType) {\n    case 'packages':\n      result.updates.packages = parsedData.packages || parsedData.updated_packages || [];\n      break;\n    case 'services':\n      result.updates.services = parsedData.services || parsedData.restarted_services || [];\n      break;\n    case 'security':\n      result.updates.security = parsedData.security_patches || parsedData.patches || [];\n      break;\n    case 'kernel':\n      result.updates.kernel = parsedData;\n      break;\n    case 'system_info':\n      result.updates.system_info = parsedData;\n      break;\n  }\n}\n\nconsole.log('Final updates:', JSON.stringify(result.updates, null, 2));\n\n// Calculate statistics\nresult.stats.total_updates = (result.updates.packages?.length || 0) + \n                              (result.updates.services?.length || 0);\nresult.stats.security_updates = result.updates.security?.length || 0;\nresult.stats.service_restarts = result.updates.services?.filter(s => s.restarted)?.length || 0;\nresult.stats.last_update = result.updates.system_info?.last_update || \n                          result.updates.packages?.[0]?.updated_at || null;\n\n// Determine status\nconst hasUpdates = result.stats.total_updates > 0;\nconst hasCritical = result.stats.security_updates > 0;\nconst indicators = getStatusIndicators(hasUpdates, hasCritical);\n\n// Create Discord-formatted summary\nconst tick3 = '```';\nlet summary = '';\nsummary += `${indicators.emoji} **Server Updates: \\`${currentIp}\\`**\\n`;\nsummary += `*Status: ${indicators.status}*\\n`;\nsummary += `*Last checked: ${new Date().toLocaleString()}*\\n\\n`;\n\n// System Information\nif (result.updates.system_info && Object.keys(result.updates.system_info).length > 0) {\n  const sys = result.updates.system_info;\n  summary += `**‚ÑπÔ∏è System Information**\\n`;\n  summary += tick3 + '\\n';\n  if (sys.os_version) summary += `OS:            ${safeValue(sys.os_version)}\\n`;\n  if (sys.kernel_version) summary += `Kernel:        ${safeValue(sys.kernel_version)}\\n`;\n  if (sys.last_update) summary += `Last Update:   ${formatDate(sys.last_update)}\\n`;\n  if (sys.uptime) summary += `Uptime:        ${safeValue(sys.uptime)}\\n`;\n  summary += tick3 + '\\n';\n}\n\n// Package Updates\nif (result.updates.packages && result.updates.packages.length > 0) {\n  summary += `**üì¶ Package Updates (${result.updates.packages.length})**\\n`;\n  summary += tick3 + '\\n';\n  const displayLimit = 10;\n  const packages = result.updates.packages.slice(0, displayLimit);\n  \n  packages.forEach(pkg => {\n    const name = pkg.name || pkg.package || pkg;\n    const oldVer = pkg.old_version ? ` ${pkg.old_version}` : '';\n    const newVer = pkg.new_version ? ` ‚Üí ${pkg.new_version}` : '';\n    summary += `‚Ä¢ ${name}${oldVer}${newVer}\\n`;\n  });\n  \n  if (result.updates.packages.length > displayLimit) {\n    summary += `... and ${result.updates.packages.length - displayLimit} more\\n`;\n  }\n  summary += tick3 + '\\n';\n}\n\n// Security Updates\nif (result.updates.security && result.updates.security.length > 0) {\n  summary += `**üîí Security Updates (${result.updates.security.length})**\\n`;\n  summary += tick3 + '\\n';\n  result.updates.security.slice(0, 5).forEach(patch => {\n    const id = patch.id || patch.cve || patch.name || patch;\n    const severity = patch.severity ? ` [${patch.severity.toUpperCase()}]` : '';\n    summary += `‚Ä¢ ${id}${severity}\\n`;\n  });\n  if (result.updates.security.length > 5) {\n    summary += `... and ${result.updates.security.length - 5} more\\n`;\n  }\n  summary += tick3 + '\\n';\n}\n\n// Service Updates/Restarts\nif (result.updates.services && result.updates.services.length > 0) {\n  summary += `**üîÑ Services Updated (${result.updates.services.length})**\\n`;\n  summary += tick3 + '\\n';\n  result.updates.services.forEach(svc => {\n    const name = svc.name || svc.service || svc;\n    const status = svc.status || svc.state || '';\n    const restarted = svc.restarted ? ' ‚Üª restarted' : '';\n    summary += `‚Ä¢ ${name} ${status}${restarted}\\n`;\n  });\n  summary += tick3 + '\\n';\n}\n\n// Kernel Update\nif (result.updates.kernel && result.updates.kernel.updated) {\n  summary += `**‚ö° Kernel Update**\\n`;\n  summary += tick3 + '\\n';\n  summary += `Old: ${safeValue(result.updates.kernel.old_version)}\\n`;\n  summary += `New: ${safeValue(result.updates.kernel.new_version)}\\n`;\n  if (result.updates.kernel.reboot_required) {\n    summary += `‚ö†Ô∏è  REBOOT REQUIRED\\n`;\n  }\n  summary += tick3 + '\\n';\n}\n\n// Summary Stats\nif (result.stats.total_updates > 0) {\n  summary += `**üìä Summary**\\n`;\n  summary += tick3 + '\\n';\n  summary += `Total Updates:      ${result.stats.total_updates}\\n`;\n  if (result.stats.security_updates > 0) {\n    summary += `Security Patches:   ${result.stats.security_updates}\\n`;\n  }\n  if (result.stats.service_restarts > 0) {\n    summary += `Services Restarted: ${result.stats.service_restarts}\\n`;\n  }\n  summary += tick3 + '\\n';\n}\n\nresult.summary = summary;\n\n// Create Discord embed\nresult.discord_embed = {\n  embeds: [{\n    title: `${indicators.emoji} ${currentIp} - ${indicators.status}`,\n    description: summary,\n    color: indicators.color,\n    timestamp: new Date().toISOString(),\n    footer: {\n      text: \"Server Update Monitor\"\n    },\n    fields: [\n      {\n        name: 'üì¶ Packages',\n        value: result.updates.packages?.length > 0 ? `${result.updates.packages.length} updated` : 'None',\n        inline: true\n      },\n      {\n        name: 'üîí Security',\n        value: result.stats.security_updates > 0 ? `${result.stats.security_updates} patches` : 'None',\n        inline: true\n      },\n      {\n        name: 'üîÑ Services',\n        value: result.updates.services?.length > 0 ? `${result.updates.services.length} affected` : 'None',\n        inline: true\n      }\n    ]\n  }]\n};\n\nreturn [{ json: result }];"
      },
      "id": "1be0dfd5-72a1-4a64-9d70-b777230e1104",
      "name": "UpdateAggregate",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1440,
        48
      ]
    }
  ],
  "pinData": {},
  "settings": {
    "executionOrder": "v1",
    "saveDataSuccessExecution": "none",
    "callerPolicy": "workflowsFromSameOwner",
    "availableInMCP": false
  },
  "shared": [
    {
      "updatedAt": "2025-11-06T03:12:24.502Z",
      "createdAt": "2025-11-06T03:12:24.502Z",
      "role": "workflow:owner",
      "workflowId": "wH0dkSQYG5ytMNCj",
      "projectId": "9tVnjhoqECLAKTN1"
    }
  ],
  "staticData": {
    "node:Trigger 1/Week/Sun": {
      "recurrenceRules": []
    }
  },
  "tags": [
    {
      "updatedAt": "2025-11-06T03:12:34.025Z",
      "createdAt": "2025-11-06T03:12:34.025Z",
      "id": "IwoPCDtQyVJy4UoS",
      "name": "update"
    },
    {
      "updatedAt": "2025-11-06T03:11:50.434Z",
      "createdAt": "2025-11-06T03:11:50.434Z",
      "id": "vgqvVrZ3n7HfHOM7",
      "name": "main"
    }
  ],
  "triggerCount": 1,
  "updatedAt": "2025-11-09T05:22:38.718Z",
  "versionId": "86eb0550-a360-4d84-81af-5d710aea8f6f"
}